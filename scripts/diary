#!/bin/bash
# Diary CLI - Query your personal diary on remote server
# Usage: diary <command> [args]

set -euo pipefail

# Configuration
TWILIGHT_HOST="${DIARY_HOST:-twilight}"
DB_PATH="/home/anicka/.recall/recall.db"

# Colors
RESET="\033[0m"
BOLD="\033[1m"
DIM="\033[2m"
RED="\033[31m"
GREEN="\033[32m"
YELLOW="\033[33m"
BLUE="\033[34m"
MAGENTA="\033[35m"
CYAN="\033[36m"

# Helper: Execute SQL on remote server (JSON mode for multi-line content)
sql_json() {
    echo "$1" | ssh "$TWILIGHT_HOST" "sqlite3 -json '$DB_PATH'"
}

# Helper: Execute SQL on remote server (simple mode for single values)
sql() {
    echo "$1" | ssh "$TWILIGHT_HOST" "sqlite3 '$DB_PATH'"
}

# Helper: Format timestamp
format_date() {
    local iso_date="$1"
    date -d "$iso_date" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "$iso_date"
}

# Helper: Wrap text to terminal width
wrap_text() {
    local text="$1"
    local indent="${2:-0}"
    local width=$(($(tput cols) - indent))
    echo "$text" | fold -s -w "$width" | sed "s/^/$(printf "%${indent}s" '')/"
}

# Helper: Display entry
show_entry() {
    local id="$1"
    local created="$2"
    local content="$3"
    local tags="$4"
    local restricted="${5:-0}"

    local restrict_badge=""
    [[ "$restricted" == "1" ]] && restrict_badge=" ${RED}[restricted]${RESET}"

    echo -e "${BOLD}${CYAN}#$id${RESET} ${DIM}$(format_date "$created")${RESET}${restrict_badge}"

    if [[ -n "$tags" ]]; then
        echo -e "${DIM}Tags: ${YELLOW}$tags${RESET}"
    fi

    echo
    wrap_text "$content" 2
    echo
    echo -e "${DIM}$(printf 'â”€%.0s' $(seq 1 $(tput cols)))${RESET}"
    echo
}

# Command: query - Search diary entries
cmd_query() {
    local query="$1"
    local limit="${2:-10}"

    echo -e "${BOLD}${BLUE}Searching for: $query${RESET}\n"

    # Use LIKE search (semantic search requires embedding service)
    local results
    results=$(sql_json "
        SELECT id, created_at, content, COALESCE(tags, '') as tags, restricted
        FROM entries
        WHERE content LIKE '%$query%' OR tags LIKE '%$query%'
        ORDER BY created_at DESC
        LIMIT $limit;
    ")

    if [[ -z "$results" || "$results" == "[]" ]]; then
        echo -e "${YELLOW}No entries found matching '$query'${RESET}"
        return
    fi

    # Parse JSON and display entries
    echo "$results" | jq -r '.[] | @json' | while read -r entry; do
        local id=$(echo "$entry" | jq -r '.id')
        local created=$(echo "$entry" | jq -r '.created_at')
        local content=$(echo "$entry" | jq -r '.content')
        local tags=$(echo "$entry" | jq -r '.tags')
        local restricted=$(echo "$entry" | jq -r '.restricted')
        show_entry "$id" "$created" "$content" "$tags" "$restricted"
    done
}

# Command: recent - List recent entries
cmd_recent() {
    local count="${1:-10}"

    echo -e "${BOLD}${BLUE}Recent $count entries:${RESET}\n"

    local results
    results=$(sql_json "
        SELECT id, created_at, content, COALESCE(tags, '') as tags, restricted
        FROM entries
        ORDER BY created_at DESC
        LIMIT $count;
    ")

    if [[ -z "$results" || "$results" == "[]" ]]; then
        echo -e "${YELLOW}No entries found${RESET}"
        return
    fi

    # Parse JSON and display entries
    echo "$results" | jq -r '.[] | @json' | while read -r entry; do
        local id=$(echo "$entry" | jq -r '.id')
        local created=$(echo "$entry" | jq -r '.created_at')
        local content=$(echo "$entry" | jq -r '.content')
        local tags=$(echo "$entry" | jq -r '.tags')
        local restricted=$(echo "$entry" | jq -r '.restricted')
        show_entry "$id" "$created" "$content" "$tags" "$restricted"
    done
}

# Command: write - Create new entry
cmd_write() {
    local content="$1"
    local tags="${2:-}"
    local conversation_id="${3:-}"
    local source="${4:-shell}"
    local restricted="${5:-1}"

    local now
    now=$(date -u +"%Y-%m-%dT%H:%M:%S.000000Z")

    # Escape single quotes in content
    content="${content//\'/\'\'}"
    tags="${tags//\'/\'\'}"

    local tag_val="NULL"
    [[ -n "$tags" ]] && tag_val="'$tags'"

    local cid_val="NULL"
    [[ -n "$conversation_id" ]] && cid_val="'$conversation_id'"

    local id
    id=$(sql "
        INSERT INTO entries (created_at, content, tags, conversation_id, source, restricted)
        VALUES ('$now', '$content', $tag_val, $cid_val, '$source', $restricted);
        SELECT last_insert_rowid();
    ")

    local badge=""
    [[ "$restricted" == "1" ]] && badge=" [restricted]"
    echo -e "${GREEN}âœ“ Entry #$id created${badge}${RESET}"
}

# Command: write-stdin - Create entry from stdin
cmd_write_stdin() {
    local non_interactive=false
    local explicit_tags=""
    local restricted=1

    # Parse flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --non-interactive|-n)
                non_interactive=true
                shift
                ;;
            --tags|-t)
                explicit_tags="$2"
                shift 2
                ;;
            --public|-p)
                restricted=0
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    # Read entire stdin
    local raw_content
    raw_content=$(cat)

    if [[ -z "$raw_content" ]]; then
        echo -e "${RED}Error: No content provided via stdin${RESET}" >&2
        return 1
    fi

    local content="$raw_content"
    local extracted_tags=""

    # 1. Try to extract YAML frontmatter
    if [[ "$raw_content" =~ ^---[[:space:]]*$'\n' ]]; then
        local frontmatter_end
        frontmatter_end=$(echo "$raw_content" | tail -n +2 | grep -n "^---[[:space:]]*$" | head -1 | cut -d: -f1)

        if [[ -n "$frontmatter_end" ]]; then
            local frontmatter
            frontmatter=$(echo "$raw_content" | head -n $((frontmatter_end + 1)) | tail -n +2 | head -n -1)

            # Extract tags from frontmatter
            local fm_tags
            fm_tags=$(echo "$frontmatter" | grep -i "^tags:" | sed 's/^tags://i' | sed 's/^[[:space:]]*//' | tr -d '[]' | tr ',' '\n' | tr -d ' ' | paste -sd,)

            if [[ -n "$fm_tags" ]]; then
                extracted_tags="$fm_tags"
            fi

            # Remove frontmatter from content
            content=$(echo "$raw_content" | tail -n +$((frontmatter_end + 2)))
        fi
    fi

    # 2. Try to extract inline hashtags (if no frontmatter tags found)
    if [[ -z "$extracted_tags" ]]; then
        local hashtags
        hashtags=$(echo "$content" | grep -o '#[a-zA-Z0-9_-]\+' | sed 's/^#//' | paste -sd, || true)

        if [[ -n "$hashtags" ]]; then
            extracted_tags="$hashtags"
        fi
    fi

    # 3. Try to extract "Tags:" line (if still no tags)
    if [[ -z "$extracted_tags" ]]; then
        local tags_line
        tags_line=$(echo "$content" | grep -i "^Tags:" | head -1 || true)

        if [[ -n "$tags_line" ]]; then
            extracted_tags=$(echo "$tags_line" | sed 's/^Tags://i' | sed 's/^[[:space:]]*//' | tr -d ' ')
            # Remove the Tags: line from content
            content=$(echo "$content" | grep -iv "^Tags:" || true)
        fi
    fi

    # Use explicit tags if provided, otherwise use extracted
    local final_tags="${explicit_tags:-$extracted_tags}"

    # 4. Interactive prompt if no tags found and terminal available
    if [[ -z "$final_tags" ]] && [[ "$non_interactive" == false ]] && [[ -t 1 ]]; then
        echo -e "${DIM}No tags found. Enter tags (comma-separated, or press Enter for none):${RESET}"
        read -r final_tags
    fi

    # Content is ready (preserving user formatting)

    # Write entry
    cmd_write "$content" "$final_tags" "" "stdin" "$restricted"
}

# Command: update - Update existing entry
cmd_update() {
    local id="$1"
    local content="$2"
    local tags="${3:-}"

    # Escape single quotes
    content="${content//\'/\'\'}"
    tags="${tags//\'/\'\'}"

    local tag_val="NULL"
    [[ -n "$tags" ]] && tag_val="'$tags'"

    sql "
        UPDATE entries
        SET content = '$content', tags = $tag_val
        WHERE id = $id;
    "

    echo -e "${GREEN}âœ“ Entry #$id updated${RESET}"
}

# Command: show - Display specific entry
cmd_show() {
    local id="$1"

    local result
    result=$(sql_json "
        SELECT id, created_at, content, COALESCE(tags, '') as tags, restricted
        FROM entries
        WHERE id = $id;
    ")

    if [[ -z "$result" || "$result" == "[]" ]]; then
        echo -e "${RED}Entry #$id not found${RESET}"
        return 1
    fi

    # Parse JSON
    local entry=$(echo "$result" | jq -r '.[0] | @json')
    local id=$(echo "$entry" | jq -r '.id')
    local created=$(echo "$entry" | jq -r '.created_at')
    local content=$(echo "$entry" | jq -r '.content')
    local tags=$(echo "$entry" | jq -r '.tags')
    local restricted=$(echo "$entry" | jq -r '.restricted')
    show_entry "$id" "$created" "$content" "$tags" "$restricted"
}

# Command: count - Count total entries
cmd_count() {
    local count
    count=$(sql "SELECT COUNT(*) FROM entries;")
    echo -e "${BOLD}${CYAN}Total entries: $count${RESET}"
}

# Command: time - Get current time
cmd_time() {
    local now
    now=$(date "+%Y-%m-%d %H:%M:%S %A")
    echo -e "${BOLD}${CYAN}$now${RESET}"
}

# Command: context - Get relevant context for a topic (alias for query)
cmd_context() {
    local topic="$1"
    local limit="${2:-5}"

    echo -e "${BOLD}${BLUE}Context for: $topic${RESET}\n"
    cmd_query "$topic" "$limit"
}

# Command: tags - List all tags
cmd_tags() {
    echo -e "${BOLD}${BLUE}All tags:${RESET}\n"

    local tags
    tags=$(sql "
        SELECT DISTINCT tags
        FROM entries
        WHERE tags IS NOT NULL
        ORDER BY tags;
    ")

    if [[ -z "$tags" ]]; then
        echo -e "${YELLOW}No tags found${RESET}"
        return
    fi

    echo "$tags" | while read -r tag; do
        # Count entries with this tag
        local count
        count=$(sql "SELECT COUNT(*) FROM entries WHERE tags LIKE '%$tag%';")
        echo -e "  ${YELLOW}$tag${RESET} ${DIM}($count entries)${RESET}"
    done
}

# Command: health recent - Show recent health data
cmd_health_recent() {
    local count="${1:-7}"

    echo -e "${BOLD}${MAGENTA}Recent $count days of health data:${RESET}\n"

    local results
    results=$(sql_json "
        SELECT date, summary
        FROM health_data
        ORDER BY date DESC
        LIMIT $count;
    ")

    if [[ -z "$results" || "$results" == "[]" ]]; then
        echo -e "${YELLOW}No health data found${RESET}"
        return
    fi

    # Parse JSON and display
    echo "$results" | jq -r '.[] | @json' | while read -r entry; do
        local date=$(echo "$entry" | jq -r '.date')
        local summary=$(echo "$entry" | jq -r '.summary')

        echo -e "${BOLD}${CYAN}ðŸ“Š $date${RESET}"
        echo
        echo "$summary"
        echo
        echo -e "${DIM}$(printf 'â”€%.0s' $(seq 1 $(tput cols)))${RESET}"
        echo
    done
}

# Command: health show - Show health data for specific date
cmd_health_show() {
    local date="$1"

    local result
    result=$(sql_json "
        SELECT date, summary, synced_at
        FROM health_data
        WHERE date = '$date';
    ")

    if [[ -z "$result" || "$result" == "[]" ]]; then
        echo -e "${RED}No health data found for $date${RESET}"
        return 1
    fi

    # Parse JSON
    local entry=$(echo "$result" | jq -r '.[0] | @json')
    local date=$(echo "$entry" | jq -r '.date')
    local summary=$(echo "$entry" | jq -r '.summary')
    local synced=$(echo "$entry" | jq -r '.synced_at')

    echo -e "${BOLD}${CYAN}ðŸ“Š Health Data: $date${RESET}"
    echo -e "${DIM}Synced: $(format_date "$synced")${RESET}"
    echo
    echo "$summary"
    echo
}

# Command: health search - Search health summaries
cmd_health_search() {
    local query="$1"
    local limit="${2:-10}"

    echo -e "${BOLD}${MAGENTA}Searching health data for: $query${RESET}\n"

    local results
    results=$(sql_json "
        SELECT date, summary
        FROM health_data
        WHERE summary LIKE '%$query%'
        ORDER BY date DESC
        LIMIT $limit;
    ")

    if [[ -z "$results" || "$results" == "[]" ]]; then
        echo -e "${YELLOW}No health data found matching '$query'${RESET}"
        return
    fi

    # Parse JSON and display
    echo "$results" | jq -r '.[] | @json' | while read -r entry; do
        local date=$(echo "$entry" | jq -r '.date')
        local summary=$(echo "$entry" | jq -r '.summary')

        echo -e "${BOLD}${CYAN}ðŸ“Š $date${RESET}"
        echo
        # Highlight search term in summary
        echo "$summary" | GREP_COLORS='mt=01;33' grep --color=always -i "$query"
        echo
        echo -e "${DIM}$(printf 'â”€%.0s' $(seq 1 $(tput cols)))${RESET}"
        echo
    done
}

# Command: health range - Show health data for date range
cmd_health_range() {
    local start_date="$1"
    local end_date="$2"

    echo -e "${BOLD}${MAGENTA}Health data from $start_date to $end_date:${RESET}\n"

    local results
    results=$(sql_json "
        SELECT date, summary
        FROM health_data
        WHERE date BETWEEN '$start_date' AND '$end_date'
        ORDER BY date DESC;
    ")

    if [[ -z "$results" || "$results" == "[]" ]]; then
        echo -e "${YELLOW}No health data found for specified range${RESET}"
        return
    fi

    # Parse JSON and display
    echo "$results" | jq -r '.[] | @json' | while read -r entry; do
        local date=$(echo "$entry" | jq -r '.date')
        local summary=$(echo "$entry" | jq -r '.summary')

        echo -e "${BOLD}${CYAN}ðŸ“Š $date${RESET}"
        echo
        echo "$summary"
        echo
        echo -e "${DIM}$(printf 'â”€%.0s' $(seq 1 $(tput cols)))${RESET}"
        echo
    done
}

# Command: health count - Count health data entries
cmd_health_count() {
    local count
    count=$(sql "SELECT COUNT(*) FROM health_data;")

    local oldest
    oldest=$(sql "SELECT MIN(date) FROM health_data;")

    local newest
    newest=$(sql "SELECT MAX(date) FROM health_data;")

    echo -e "${BOLD}${CYAN}Health data statistics:${RESET}"
    echo -e "  Total days tracked: ${GREEN}$count${RESET}"
    echo -e "  Oldest record: ${DIM}$oldest${RESET}"
    echo -e "  Newest record: ${DIM}$newest${RESET}"
}

# Command: cycle - Show cycle status
cmd_cycle() {
    local use_last="${1:-6}"

    # Fetch recent cycle starts
    local dates
    dates=$(sql "
        SELECT date FROM cycle_starts
        ORDER BY date DESC
        LIMIT $((use_last + 1));
    ")

    if [[ -z "$dates" ]]; then
        echo -e "${YELLOW}No cycle data found${RESET}"
        return
    fi

    # Convert to array
    local -a starts
    while IFS= read -r d; do
        starts+=("$d")
    done <<< "$dates"

    local last="${starts[0]}"
    local today
    today=$(date +%Y-%m-%d)

    # Calculate cycle lengths from recent starts
    local -a lengths
    local sum=0 min=999 max=0 count=0
    for ((i=0; i < ${#starts[@]} - 1; i++)); do
        local d1 d2 diff
        d1=$(date -d "${starts[$i]}" +%s)
        d2=$(date -d "${starts[$((i+1))]}" +%s)
        diff=$(( (d1 - d2) / 86400 ))
        lengths+=("$diff")
        sum=$((sum + diff))
        (( diff < min )) && min=$diff
        (( diff > max )) && max=$diff
        count=$((count + 1))
    done

    if [[ $count -eq 0 ]]; then
        echo -e "${YELLOW}Need at least 2 cycle starts for statistics${RESET}"
        return
    fi

    local avg=$((sum / count))
    local today_epoch last_epoch day_in_cycle days_left expected
    today_epoch=$(date +%s)
    last_epoch=$(date -d "$last" +%s)
    day_in_cycle=$(( (today_epoch - last_epoch) / 86400 ))
    days_left=$((avg - day_in_cycle))
    expected=$(date -d "$last + $avg days" +%Y-%m-%d)

    # Period phase (first ~5 days)
    local period_len=5
    local phase phase_color
    if (( day_in_cycle < period_len )); then
        phase="period"
        phase_color="$RED"
    elif (( days_left <= 3 && days_left >= -3 )); then
        phase="due"
        phase_color="$YELLOW"
    else
        phase="cycle"
        phase_color="$GREEN"
    fi

    # Header
    echo -e "${BOLD}${MAGENTA}Cycle Status${RESET}"
    echo

    # Progress bar
    local bar_width=40
    local filled=$(( (day_in_cycle * bar_width) / avg ))
    (( filled > bar_width )) && filled=$bar_width
    local empty=$((bar_width - filled))
    local bar=""
    for ((i=0; i<filled; i++)); do bar+="â–ˆ"; done
    for ((i=0; i<empty; i++)); do bar+="â–‘"; done

    echo -e "  ${phase_color}${bar}${RESET} day ${BOLD}${day_in_cycle}${RESET}/${avg}"
    echo

    # Details
    echo -e "  Last start:   ${BOLD}${last}${RESET}"
    echo -e "  Expected:     ${BOLD}${expected}${RESET}${RESET}"
    if (( days_left > 0 )); then
        echo -e "  Days left:    ${phase_color}~${days_left}${RESET}"
    elif (( days_left == 0 )); then
        echo -e "  Days left:    ${YELLOW}today${RESET}"
    else
        echo -e "  Days over:    ${RED}$((-days_left))${RESET}"
    fi
    echo

    # Stats
    echo -e "  ${DIM}avg ${avg}d | min ${min}d | max ${max}d | last ${count} cycles${RESET}"

    # Recent cycle lengths
    echo -ne "  ${DIM}recent: "
    for ((i=0; i < ${#lengths[@]}; i++)); do
        (( i > 0 )) && echo -n " "
        echo -n "${lengths[$i]}"
    done
    echo -e "${RESET}"
}

# Command: cycle-log - Record a new cycle start
cmd_cycle_log() {
    local date="${1:-$(date +%Y-%m-%d)}"
    local notes="${2:-}"
    local now
    now=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    notes="${notes//\'/\'\'}"

    sql "
        INSERT OR REPLACE INTO cycle_starts (date, notes, created_at)
        VALUES ('$date', $([ -n "$notes" ] && echo "'$notes'" || echo "NULL"), '$now');
    "

    echo -e "${GREEN}âœ“ Cycle start recorded: ${date}${RESET}"
}

# Command: help
cmd_help() {
    cat << 'EOF'
Diary CLI - Query your personal diary and health data

USAGE:
    diary <command> [arguments]

DIARY COMMANDS:
    query <text> [limit]     Search entries (default limit: 10)
    recent [count]           List recent entries (default: 10)
    write [-p] <content> [tags]  Create new entry (restricted by default, -p for public)
    write-stdin [options]    Create entry from stdin (restricted by default)
    update <id> <content> [tags]  Update entry
    show <id>                Show specific entry
    count                    Count total entries
    time                     Show current time
    context <topic> [limit]  Get context for topic (alias for query)
    tags                     List all tags with counts

CYCLE COMMANDS:
    cycle                    Show current cycle status
    cycle-log [date] [note]  Record a cycle start (default: today)

HEALTH COMMANDS:
    health recent [days]     Show recent health data (default: 7)
    health show <date>       Show health data for specific date (YYYY-MM-DD)
    health search <term>     Search health summaries
    health range <start> <end>  Show health data for date range
    health count             Count health data entries

WRITE OPTIONS:
    --public, -p             Save as unrestricted (visible to coding instances)
                             Default: restricted (private, only visible via CLI/OAuth)

STDIN OPTIONS:
    --tags, -t <tags>        Explicit tags (overrides auto-detection)
    --non-interactive, -n    Don't prompt for tags if none found
    --public, -p             Save as unrestricted

STDIN TAG DETECTION:
    1. YAML frontmatter:     ---\ntags: tag1, tag2\n---
    2. Inline hashtags:      #meditation #practice
    3. Tags line:            Tags: meditation, practice
    4. Interactive prompt:   (if terminal available and not --non-interactive)

EXAMPLES:
    # Diary
    diary recent 5
    diary query "practice" 20
    diary write "Made progress on karma-electric" "coding,dharma"   # restricted
    diary write -p "Deployed v5 to production" "deployment"          # public
    diary context "meditation"
    diary tags

    # Health data
    # Cycle
    diary cycle
    diary cycle-log
    diary cycle-log 2026-02-15 "early start"

    # Health data
    diary health recent 10
    diary health show 2026-02-09
    diary health search "sleep"
    diary health range 2026-02-01 2026-02-10
    diary health count

    # Stdin ingestion
    cat entry.txt | diary write-stdin
    cat entry-with-frontmatter.md | diary stdin
    echo "Quick note #practice" | diary stdin
    cat entry.txt | diary stdin --tags "custom,tags"
    cat entry.txt | diary stdin --non-interactive

The database is queried via SSH to \$TWILIGHT_HOST:~/.recall/recall.db
EOF
}

# Main
main() {
    if [[ $# -eq 0 ]]; then
        cmd_help
        exit 0
    fi

    local command="$1"
    shift

    case "$command" in
        query|q|search)
            [[ $# -eq 0 ]] && { echo -e "${RED}Error: query requires search text${RESET}"; exit 1; }
            cmd_query "$@"
            ;;
        recent|r|list)
            cmd_recent "$@"
            ;;
        write|w|add)
            local _restricted=1
            [[ "$1" == "--public" || "$1" == "-p" ]] && { _restricted=0; shift; }
            [[ $# -eq 0 ]] && { echo -e "${RED}Error: write requires content${RESET}"; exit 1; }
            cmd_write "$1" "${2:-}" "" "shell" "$_restricted"
            ;;
        write-stdin|stdin|-)
            cmd_write_stdin "$@"
            ;;
        update|u|edit)
            [[ $# -lt 2 ]] && { echo -e "${RED}Error: update requires id and content${RESET}"; exit 1; }
            cmd_update "$@"
            ;;
        show|s|get)
            [[ $# -eq 0 ]] && { echo -e "${RED}Error: show requires entry id${RESET}"; exit 1; }
            cmd_show "$@"
            ;;
        count|c)
            cmd_count
            ;;
        time|t)
            cmd_time
            ;;
        context|ctx)
            [[ $# -eq 0 ]] && { echo -e "${RED}Error: context requires topic${RESET}"; exit 1; }
            cmd_context "$@"
            ;;
        tags)
            cmd_tags
            ;;
        cycle)
            cmd_cycle "$@"
            ;;
        cycle-log|log)
            cmd_cycle_log "$@"
            ;;
        health)
            [[ $# -eq 0 ]] && { echo -e "${RED}Error: health requires subcommand${RESET}"; exit 1; }
            local subcmd="$1"
            shift
            case "$subcmd" in
                recent|r)
                    cmd_health_recent "$@"
                    ;;
                show|s)
                    [[ $# -eq 0 ]] && { echo -e "${RED}Error: health show requires date${RESET}"; exit 1; }
                    cmd_health_show "$@"
                    ;;
                search|q)
                    [[ $# -eq 0 ]] && { echo -e "${RED}Error: health search requires search term${RESET}"; exit 1; }
                    cmd_health_search "$@"
                    ;;
                range)
                    [[ $# -lt 2 ]] && { echo -e "${RED}Error: health range requires start and end dates${RESET}"; exit 1; }
                    cmd_health_range "$@"
                    ;;
                count|c)
                    cmd_health_count
                    ;;
                *)
                    echo -e "${RED}Unknown health subcommand: $subcmd${RESET}"
                    echo
                    cmd_help
                    exit 1
                    ;;
            esac
            ;;
        help|h|-h|--help)
            cmd_help
            ;;
        *)
            echo -e "${RED}Unknown command: $command${RESET}"
            echo
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
