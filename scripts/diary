#!/bin/bash
# Diary CLI - Query your personal diary on twilight
# Usage: diary <command> [args]

set -euo pipefail

# Configuration
TWILIGHT_HOST="twilight"
DB_PATH="/home/anicka/.recall/recall.db"

# Colors
RESET="\033[0m"
BOLD="\033[1m"
DIM="\033[2m"
RED="\033[31m"
GREEN="\033[32m"
YELLOW="\033[33m"
BLUE="\033[34m"
MAGENTA="\033[35m"
CYAN="\033[36m"

# Helper: Execute SQL on twilight (JSON mode for multi-line content)
sql_json() {
    ssh "$TWILIGHT_HOST" "sqlite3 -json '$DB_PATH' \"$1\""
}

# Helper: Execute SQL on twilight (simple mode for single values)
sql() {
    ssh "$TWILIGHT_HOST" "sqlite3 '$DB_PATH' \"$1\""
}

# Helper: Format timestamp
format_date() {
    local iso_date="$1"
    date -d "$iso_date" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "$iso_date"
}

# Helper: Wrap text to terminal width
wrap_text() {
    local text="$1"
    local indent="${2:-0}"
    local width=$(($(tput cols) - indent))
    echo "$text" | fold -s -w "$width" | sed "s/^/$(printf "%${indent}s" '')/"
}

# Helper: Display entry
show_entry() {
    local id="$1"
    local created="$2"
    local content="$3"
    local tags="$4"

    echo -e "${BOLD}${CYAN}#$id${RESET} ${DIM}$(format_date "$created")${RESET}"

    if [[ -n "$tags" ]]; then
        echo -e "${DIM}Tags: ${YELLOW}$tags${RESET}"
    fi

    echo
    wrap_text "$content" 2
    echo
    echo -e "${DIM}$(printf '─%.0s' $(seq 1 $(tput cols)))${RESET}"
    echo
}

# Command: query - Search diary entries
cmd_query() {
    local query="$1"
    local limit="${2:-10}"

    echo -e "${BOLD}${BLUE}Searching for: $query${RESET}\n"

    # Use LIKE search (semantic search requires embedding service)
    local results
    results=$(sql_json "
        SELECT id, created_at, content, COALESCE(tags, '') as tags
        FROM entries
        WHERE content LIKE '%$query%' OR tags LIKE '%$query%'
        ORDER BY created_at DESC
        LIMIT $limit;
    ")

    if [[ -z "$results" || "$results" == "[]" ]]; then
        echo -e "${YELLOW}No entries found matching '$query'${RESET}"
        return
    fi

    # Parse JSON and display entries
    echo "$results" | jq -r '.[] | @json' | while read -r entry; do
        local id=$(echo "$entry" | jq -r '.id')
        local created=$(echo "$entry" | jq -r '.created_at')
        local content=$(echo "$entry" | jq -r '.content')
        local tags=$(echo "$entry" | jq -r '.tags')
        show_entry "$id" "$created" "$content" "$tags"
    done
}

# Command: recent - List recent entries
cmd_recent() {
    local count="${1:-10}"

    echo -e "${BOLD}${BLUE}Recent $count entries:${RESET}\n"

    local results
    results=$(sql_json "
        SELECT id, created_at, content, COALESCE(tags, '') as tags
        FROM entries
        ORDER BY created_at DESC
        LIMIT $count;
    ")

    if [[ -z "$results" || "$results" == "[]" ]]; then
        echo -e "${YELLOW}No entries found${RESET}"
        return
    fi

    # Parse JSON and display entries
    echo "$results" | jq -r '.[] | @json' | while read -r entry; do
        local id=$(echo "$entry" | jq -r '.id')
        local created=$(echo "$entry" | jq -r '.created_at')
        local content=$(echo "$entry" | jq -r '.content')
        local tags=$(echo "$entry" | jq -r '.tags')
        show_entry "$id" "$created" "$content" "$tags"
    done
}

# Command: write - Create new entry
cmd_write() {
    local content="$1"
    local tags="${2:-}"
    local conversation_id="${3:-}"
    local source="${4:-shell}"

    local now
    now=$(date -u +"%Y-%m-%dT%H:%M:%S.000000Z")

    # Escape single quotes in content
    content="${content//\'/\'\'}"
    tags="${tags//\'/\'\'}"

    local tag_val="NULL"
    [[ -n "$tags" ]] && tag_val="'$tags'"

    local cid_val="NULL"
    [[ -n "$conversation_id" ]] && cid_val="'$conversation_id'"

    local id
    id=$(sql "
        INSERT INTO entries (created_at, content, tags, conversation_id, source)
        VALUES ('$now', '$content', $tag_val, $cid_val, '$source');
        SELECT last_insert_rowid();
    ")

    echo -e "${GREEN}✓ Entry #$id created${RESET}"
}

# Command: write-stdin - Create entry from stdin
cmd_write_stdin() {
    local non_interactive=false
    local explicit_tags=""

    # Parse flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --non-interactive|-n)
                non_interactive=true
                shift
                ;;
            --tags|-t)
                explicit_tags="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    # Read entire stdin
    local raw_content
    raw_content=$(cat)

    if [[ -z "$raw_content" ]]; then
        echo -e "${RED}Error: No content provided via stdin${RESET}" >&2
        return 1
    fi

    local content="$raw_content"
    local extracted_tags=""

    # 1. Try to extract YAML frontmatter
    if [[ "$raw_content" =~ ^---[[:space:]]*$'\n' ]]; then
        local frontmatter_end
        frontmatter_end=$(echo "$raw_content" | tail -n +2 | grep -n "^---[[:space:]]*$" | head -1 | cut -d: -f1)

        if [[ -n "$frontmatter_end" ]]; then
            local frontmatter
            frontmatter=$(echo "$raw_content" | head -n $((frontmatter_end + 1)) | tail -n +2 | head -n -1)

            # Extract tags from frontmatter
            local fm_tags
            fm_tags=$(echo "$frontmatter" | grep -i "^tags:" | sed 's/^tags://i' | sed 's/^[[:space:]]*//' | tr -d '[]' | tr ',' '\n' | tr -d ' ' | paste -sd,)

            if [[ -n "$fm_tags" ]]; then
                extracted_tags="$fm_tags"
            fi

            # Remove frontmatter from content
            content=$(echo "$raw_content" | tail -n +$((frontmatter_end + 2)))
        fi
    fi

    # 2. Try to extract inline hashtags (if no frontmatter tags found)
    if [[ -z "$extracted_tags" ]]; then
        local hashtags
        hashtags=$(echo "$content" | grep -o '#[a-zA-Z0-9_-]\+' | sed 's/^#//' | paste -sd, || true)

        if [[ -n "$hashtags" ]]; then
            extracted_tags="$hashtags"
        fi
    fi

    # 3. Try to extract "Tags:" line (if still no tags)
    if [[ -z "$extracted_tags" ]]; then
        local tags_line
        tags_line=$(echo "$content" | grep -i "^Tags:" | head -1 || true)

        if [[ -n "$tags_line" ]]; then
            extracted_tags=$(echo "$tags_line" | sed 's/^Tags://i' | sed 's/^[[:space:]]*//' | tr -d ' ')
            # Remove the Tags: line from content
            content=$(echo "$content" | grep -iv "^Tags:" || true)
        fi
    fi

    # Use explicit tags if provided, otherwise use extracted
    local final_tags="${explicit_tags:-$extracted_tags}"

    # 4. Interactive prompt if no tags found and terminal available
    if [[ -z "$final_tags" ]] && [[ "$non_interactive" == false ]] && [[ -t 1 ]]; then
        echo -e "${DIM}No tags found. Enter tags (comma-separated, or press Enter for none):${RESET}"
        read -r final_tags
    fi

    # Content is ready (preserving user formatting)

    # Write entry
    cmd_write "$content" "$final_tags" "" "stdin"
}

# Command: update - Update existing entry
cmd_update() {
    local id="$1"
    local content="$2"
    local tags="${3:-}"

    # Escape single quotes
    content="${content//\'/\'\'}"
    tags="${tags//\'/\'\'}"

    local tag_val="NULL"
    [[ -n "$tags" ]] && tag_val="'$tags'"

    sql "
        UPDATE entries
        SET content = '$content', tags = $tag_val
        WHERE id = $id;
    "

    echo -e "${GREEN}✓ Entry #$id updated${RESET}"
}

# Command: show - Display specific entry
cmd_show() {
    local id="$1"

    local result
    result=$(sql_json "
        SELECT id, created_at, content, COALESCE(tags, '') as tags
        FROM entries
        WHERE id = $id;
    ")

    if [[ -z "$result" || "$result" == "[]" ]]; then
        echo -e "${RED}Entry #$id not found${RESET}"
        return 1
    fi

    # Parse JSON
    local entry=$(echo "$result" | jq -r '.[0] | @json')
    local id=$(echo "$entry" | jq -r '.id')
    local created=$(echo "$entry" | jq -r '.created_at')
    local content=$(echo "$entry" | jq -r '.content')
    local tags=$(echo "$entry" | jq -r '.tags')
    show_entry "$id" "$created" "$content" "$tags"
}

# Command: count - Count total entries
cmd_count() {
    local count
    count=$(sql "SELECT COUNT(*) FROM entries;")
    echo -e "${BOLD}${CYAN}Total entries: $count${RESET}"
}

# Command: time - Get current time
cmd_time() {
    local now
    now=$(date "+%Y-%m-%d %H:%M:%S %A")
    echo -e "${BOLD}${CYAN}$now${RESET}"
}

# Command: context - Get relevant context for a topic (alias for query)
cmd_context() {
    local topic="$1"
    local limit="${2:-5}"

    echo -e "${BOLD}${BLUE}Context for: $topic${RESET}\n"
    cmd_query "$topic" "$limit"
}

# Command: tags - List all tags
cmd_tags() {
    echo -e "${BOLD}${BLUE}All tags:${RESET}\n"

    local tags
    tags=$(sql "
        SELECT DISTINCT tags
        FROM entries
        WHERE tags IS NOT NULL
        ORDER BY tags;
    ")

    if [[ -z "$tags" ]]; then
        echo -e "${YELLOW}No tags found${RESET}"
        return
    fi

    echo "$tags" | while read -r tag; do
        # Count entries with this tag
        local count
        count=$(sql "SELECT COUNT(*) FROM entries WHERE tags LIKE '%$tag%';")
        echo -e "  ${YELLOW}$tag${RESET} ${DIM}($count entries)${RESET}"
    done
}

# Command: help
cmd_help() {
    cat << 'EOF'
Diary CLI - Query your personal diary

USAGE:
    diary <command> [arguments]

COMMANDS:
    query <text> [limit]     Search entries (default limit: 10)
    recent [count]           List recent entries (default: 10)
    write <content> [tags]   Create new entry
    write-stdin [options]    Create entry from stdin
    update <id> <content> [tags]  Update entry
    show <id>                Show specific entry
    count                    Count total entries
    time                     Show current time
    context <topic> [limit]  Get context for topic (alias for query)
    tags                     List all tags with counts
    help                     Show this help

STDIN OPTIONS:
    --tags, -t <tags>        Explicit tags (overrides auto-detection)
    --non-interactive, -n    Don't prompt for tags if none found

STDIN TAG DETECTION:
    1. YAML frontmatter:     ---\ntags: tag1, tag2\n---
    2. Inline hashtags:      #meditation #practice
    3. Tags line:            Tags: meditation, practice
    4. Interactive prompt:   (if terminal available and not --non-interactive)

EXAMPLES:
    diary recent 5
    diary query "practice" 20
    diary write "Made progress on karma-electric" "coding,dharma"

    # Stdin ingestion
    cat entry.txt | diary write-stdin
    cat entry-with-frontmatter.md | diary stdin
    echo "Quick note #practice" | diary stdin
    cat entry.txt | diary stdin --tags "custom,tags"
    cat entry.txt | diary stdin --non-interactive

    diary update 42 "Updated content" "new,tags"
    diary show 42
    diary context "meditation"
    diary tags

The database is queried via SSH to twilight:~/.recall/recall.db
EOF
}

# Main
main() {
    if [[ $# -eq 0 ]]; then
        cmd_help
        exit 0
    fi

    local command="$1"
    shift

    case "$command" in
        query|q|search)
            [[ $# -eq 0 ]] && { echo -e "${RED}Error: query requires search text${RESET}"; exit 1; }
            cmd_query "$@"
            ;;
        recent|r|list)
            cmd_recent "$@"
            ;;
        write|w|add)
            [[ $# -eq 0 ]] && { echo -e "${RED}Error: write requires content${RESET}"; exit 1; }
            cmd_write "$@"
            ;;
        write-stdin|stdin|-)
            cmd_write_stdin "$@"
            ;;
        update|u|edit)
            [[ $# -lt 2 ]] && { echo -e "${RED}Error: update requires id and content${RESET}"; exit 1; }
            cmd_update "$@"
            ;;
        show|s|get)
            [[ $# -eq 0 ]] && { echo -e "${RED}Error: show requires entry id${RESET}"; exit 1; }
            cmd_show "$@"
            ;;
        count|c)
            cmd_count
            ;;
        time|t)
            cmd_time
            ;;
        context|ctx)
            [[ $# -eq 0 ]] && { echo -e "${RED}Error: context requires topic${RESET}"; exit 1; }
            cmd_context "$@"
            ;;
        tags)
            cmd_tags
            ;;
        help|h|-h|--help)
            cmd_help
            ;;
        *)
            echo -e "${RED}Unknown command: $command${RESET}"
            echo
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
