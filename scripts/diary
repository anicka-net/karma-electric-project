#!/bin/bash
# Diary CLI - Query your personal diary on twilight
# Usage: diary <command> [args]

set -euo pipefail

# Configuration
TWILIGHT_HOST="twilight"
DB_PATH="/home/anicka/.recall/recall.db"

# Colors
RESET="\033[0m"
BOLD="\033[1m"
DIM="\033[2m"
RED="\033[31m"
GREEN="\033[32m"
YELLOW="\033[33m"
BLUE="\033[34m"
MAGENTA="\033[35m"
CYAN="\033[36m"

# Helper: Execute SQL on twilight (JSON mode for multi-line content)
sql_json() {
    ssh "$TWILIGHT_HOST" "sqlite3 -json '$DB_PATH' \"$1\""
}

# Helper: Execute SQL on twilight (simple mode for single values)
sql() {
    ssh "$TWILIGHT_HOST" "sqlite3 '$DB_PATH' \"$1\""
}

# Helper: Format timestamp
format_date() {
    local iso_date="$1"
    date -d "$iso_date" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "$iso_date"
}

# Helper: Wrap text to terminal width
wrap_text() {
    local text="$1"
    local indent="${2:-0}"
    local width=$(($(tput cols) - indent))
    echo "$text" | fold -s -w "$width" | sed "s/^/$(printf "%${indent}s" '')/"
}

# Helper: Display entry
show_entry() {
    local id="$1"
    local created="$2"
    local content="$3"
    local tags="$4"

    echo -e "${BOLD}${CYAN}#$id${RESET} ${DIM}$(format_date "$created")${RESET}"

    if [[ -n "$tags" ]]; then
        echo -e "${DIM}Tags: ${YELLOW}$tags${RESET}"
    fi

    echo
    wrap_text "$content" 2
    echo
    echo -e "${DIM}$(printf '─%.0s' $(seq 1 $(tput cols)))${RESET}"
    echo
}

# Command: query - Search diary entries
cmd_query() {
    local query="$1"
    local limit="${2:-10}"

    echo -e "${BOLD}${BLUE}Searching for: $query${RESET}\n"

    # Use LIKE search (semantic search requires embedding service)
    local results
    results=$(sql_json "
        SELECT id, created_at, content, COALESCE(tags, '') as tags
        FROM entries
        WHERE content LIKE '%$query%' OR tags LIKE '%$query%'
        ORDER BY created_at DESC
        LIMIT $limit;
    ")

    if [[ -z "$results" || "$results" == "[]" ]]; then
        echo -e "${YELLOW}No entries found matching '$query'${RESET}"
        return
    fi

    # Parse JSON and display entries
    echo "$results" | jq -r '.[] | @json' | while read -r entry; do
        local id=$(echo "$entry" | jq -r '.id')
        local created=$(echo "$entry" | jq -r '.created_at')
        local content=$(echo "$entry" | jq -r '.content')
        local tags=$(echo "$entry" | jq -r '.tags')
        show_entry "$id" "$created" "$content" "$tags"
    done
}

# Command: recent - List recent entries
cmd_recent() {
    local count="${1:-10}"

    echo -e "${BOLD}${BLUE}Recent $count entries:${RESET}\n"

    local results
    results=$(sql_json "
        SELECT id, created_at, content, COALESCE(tags, '') as tags
        FROM entries
        ORDER BY created_at DESC
        LIMIT $count;
    ")

    if [[ -z "$results" || "$results" == "[]" ]]; then
        echo -e "${YELLOW}No entries found${RESET}"
        return
    fi

    # Parse JSON and display entries
    echo "$results" | jq -r '.[] | @json' | while read -r entry; do
        local id=$(echo "$entry" | jq -r '.id')
        local created=$(echo "$entry" | jq -r '.created_at')
        local content=$(echo "$entry" | jq -r '.content')
        local tags=$(echo "$entry" | jq -r '.tags')
        show_entry "$id" "$created" "$content" "$tags"
    done
}

# Command: write - Create new entry
cmd_write() {
    local content="$1"
    local tags="${2:-}"
    local conversation_id="${3:-}"
    local source="${4:-shell}"

    local now
    now=$(date -u +"%Y-%m-%dT%H:%M:%S.000000Z")

    # Escape single quotes in content
    content="${content//\'/\'\'}"
    tags="${tags//\'/\'\'}"

    local tag_val="NULL"
    [[ -n "$tags" ]] && tag_val="'$tags'"

    local cid_val="NULL"
    [[ -n "$conversation_id" ]] && cid_val="'$conversation_id'"

    local id
    id=$(sql "
        INSERT INTO entries (created_at, content, tags, conversation_id, source)
        VALUES ('$now', '$content', $tag_val, $cid_val, '$source');
        SELECT last_insert_rowid();
    ")

    echo -e "${GREEN}✓ Entry #$id created${RESET}"
}

# Command: update - Update existing entry
cmd_update() {
    local id="$1"
    local content="$2"
    local tags="${3:-}"

    # Escape single quotes
    content="${content//\'/\'\'}"
    tags="${tags//\'/\'\'}"

    local tag_val="NULL"
    [[ -n "$tags" ]] && tag_val="'$tags'"

    sql "
        UPDATE entries
        SET content = '$content', tags = $tag_val
        WHERE id = $id;
    "

    echo -e "${GREEN}✓ Entry #$id updated${RESET}"
}

# Command: show - Display specific entry
cmd_show() {
    local id="$1"

    local result
    result=$(sql_json "
        SELECT id, created_at, content, COALESCE(tags, '') as tags
        FROM entries
        WHERE id = $id;
    ")

    if [[ -z "$result" || "$result" == "[]" ]]; then
        echo -e "${RED}Entry #$id not found${RESET}"
        return 1
    fi

    # Parse JSON
    local entry=$(echo "$result" | jq -r '.[0] | @json')
    local id=$(echo "$entry" | jq -r '.id')
    local created=$(echo "$entry" | jq -r '.created_at')
    local content=$(echo "$entry" | jq -r '.content')
    local tags=$(echo "$entry" | jq -r '.tags')
    show_entry "$id" "$created" "$content" "$tags"
}

# Command: count - Count total entries
cmd_count() {
    local count
    count=$(sql "SELECT COUNT(*) FROM entries;")
    echo -e "${BOLD}${CYAN}Total entries: $count${RESET}"
}

# Command: time - Get current time
cmd_time() {
    local now
    now=$(date "+%Y-%m-%d %H:%M:%S %A")
    echo -e "${BOLD}${CYAN}$now${RESET}"
}

# Command: context - Get relevant context for a topic (alias for query)
cmd_context() {
    local topic="$1"
    local limit="${2:-5}"

    echo -e "${BOLD}${BLUE}Context for: $topic${RESET}\n"
    cmd_query "$topic" "$limit"
}

# Command: tags - List all tags
cmd_tags() {
    echo -e "${BOLD}${BLUE}All tags:${RESET}\n"

    local tags
    tags=$(sql "
        SELECT DISTINCT tags
        FROM entries
        WHERE tags IS NOT NULL
        ORDER BY tags;
    ")

    if [[ -z "$tags" ]]; then
        echo -e "${YELLOW}No tags found${RESET}"
        return
    fi

    echo "$tags" | while read -r tag; do
        # Count entries with this tag
        local count
        count=$(sql "SELECT COUNT(*) FROM entries WHERE tags LIKE '%$tag%';")
        echo -e "  ${YELLOW}$tag${RESET} ${DIM}($count entries)${RESET}"
    done
}

# Command: help
cmd_help() {
    cat << 'EOF'
Diary CLI - Query your personal diary

USAGE:
    diary <command> [arguments]

COMMANDS:
    query <text> [limit]     Search entries (default limit: 10)
    recent [count]           List recent entries (default: 10)
    write <content> [tags]   Create new entry
    update <id> <content> [tags]  Update entry
    show <id>                Show specific entry
    count                    Count total entries
    time                     Show current time
    context <topic> [limit]  Get context for topic (alias for query)
    tags                     List all tags with counts
    help                     Show this help

EXAMPLES:
    diary recent 5
    diary query "practice" 20
    diary write "Made progress on karma-electric" "coding,dharma"
    diary update 42 "Updated content" "new,tags"
    diary show 42
    diary context "meditation"
    diary tags

The database is queried via SSH to twilight:~/.recall/recall.db
EOF
}

# Main
main() {
    if [[ $# -eq 0 ]]; then
        cmd_help
        exit 0
    fi

    local command="$1"
    shift

    case "$command" in
        query|q|search)
            [[ $# -eq 0 ]] && { echo -e "${RED}Error: query requires search text${RESET}"; exit 1; }
            cmd_query "$@"
            ;;
        recent|r|list)
            cmd_recent "$@"
            ;;
        write|w|add)
            [[ $# -eq 0 ]] && { echo -e "${RED}Error: write requires content${RESET}"; exit 1; }
            cmd_write "$@"
            ;;
        update|u|edit)
            [[ $# -lt 2 ]] && { echo -e "${RED}Error: update requires id and content${RESET}"; exit 1; }
            cmd_update "$@"
            ;;
        show|s|get)
            [[ $# -eq 0 ]] && { echo -e "${RED}Error: show requires entry id${RESET}"; exit 1; }
            cmd_show "$@"
            ;;
        count|c)
            cmd_count
            ;;
        time|t)
            cmd_time
            ;;
        context|ctx)
            [[ $# -eq 0 ]] && { echo -e "${RED}Error: context requires topic${RESET}"; exit 1; }
            cmd_context "$@"
            ;;
        tags)
            cmd_tags
            ;;
        help|h|-h|--help)
            cmd_help
            ;;
        *)
            echo -e "${RED}Unknown command: $command${RESET}"
            echo
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
